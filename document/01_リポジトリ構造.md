# リポジトリ構造の詳細説明

このドキュメントでは、intuitiveプロジェクトの構造について、初学者向けに詳しく説明します。

## 目次

1. [プロジェクト全体の構造](#プロジェクト全体の構造)
2. [各ファイルの役割](#各ファイルの役割)
3. [フロントエンドとバックエンドが共存できる仕組み](#フロントエンドとバックエンドが共存できる仕組み)
4. [実行時の動作フロー](#実行時の動作フロー)
5. [TypeScriptのコンパイルタイミング](#typescriptのコンパイルタイミング)

---

## プロジェクト全体の構造

```
intuitive/
├── src/                          # ソースコード
│   ├── backend/                  # バックエンド（Hono）
│   │   └── index.ts              # APIサーバーのエントリーポイント
│   └── frontend/                 # フロントエンド（React）
│       ├── App.tsx               # Reactメインコンポーネント
│       ├── App.css               # スタイル
│       └── main.tsx              # Reactエントリーポイント
│
├── document/                     # ドキュメント
│   └── repository-structure.md  # このファイル
│
├── index.html                    # HTMLテンプレート
├── package.json                  # 依存関係とスクリプト
├── bun.lock                      # 依存関係のロックファイル
│
├── tsconfig.json                 # フロントエンド用TypeScript設定
├── tsconfig.backend.json         # バックエンド用TypeScript設定
├── vite.config.ts                # Vite設定（フロントエンドビルド）
│
├── .gitignore                    # Git無視設定
└── README.md                     # プロジェクト説明
```

---

## 各ファイルの役割

### ルート直下のファイル

#### 📄 `package.json`
**役割**: プロジェクト全体の設定ファイル

```json
{
  "name": "intuitive",
  "scripts": {
    "dev": "bun run dev:backend & bun run dev:frontend",
    "dev:backend": "bun run --hot src/backend/index.ts",
    "dev:frontend": "vite"
  },
  "dependencies": {
    "hono": "^4.11.3",       // バックエンドフレームワーク
    "react": "^19.2.3",      // フロントエンドライブラリ
    "react-dom": "^19.2.3"   // ReactのDOM操作
  },
  "devDependencies": {
    "@types/react": "^19.2.7",        // React型定義
    "@vitejs/plugin-react": "^5.1.2",  // Vite用Reactプラグイン
    "vite": "^7.3.0"                   // フロントエンドビルドツール
  }
}
```

**できること**:
- 依存ライブラリの管理（React、Hono等）
- 実行コマンドの定義（`bun run dev`等）
- プロジェクトのメタ情報

**なぜ1つだけ？**:
現在の構成では、フロントエンドとバックエンドの依存関係を**まとめて**管理しています。

---

#### 📄 `tsconfig.json`
**役割**: **フロントエンド用**TypeScriptコンパイラ設定

```json
{
  "compilerOptions": {
    "jsx": "react-jsx",              // ReactのJSXを使う
    "lib": ["ESNext", "DOM"],        // ブラウザAPIを使える
    "types": ["vite/client"]         // Vite専用の型定義
  },
  "include": ["src/frontend/**/*"],  // フロントエンドだけ対象
  "exclude": ["src/backend"]         // バックエンドは除外
}
```

**重要なポイント**:
- `jsx: "react-jsx"` → ReactのJSX構文をサポート
- `lib: ["DOM"]` → `document`, `window`等のブラウザAPIが使える
- `include: ["src/frontend/**/*"]` → フロントエンドのみ対象

---

#### 📄 `tsconfig.backend.json`
**役割**: **バックエンド用**TypeScriptコンパイラ設定

```json
{
  "compilerOptions": {
    "lib": ["ESNext"],               // ブラウザAPI不要
    "types": ["bun"]                 // Bunランタイムの型定義
  },
  "include": ["src/backend/**/*"]    // バックエンドだけ対象
}
```

**重要なポイント**:
- `lib: ["ESNext"]`のみ → DOM APIは含まれない（サーバー用）
- `types: ["bun"]` → Bunランタイム専用の型定義
- `include: ["src/backend/**/*"]` → バックエンドのみ対象

**なぜ2つに分けた？**:
- フロントエンド：ブラウザで動くのでDOM APIが必要
- バックエンド：サーバーで動くのでDOM APIは不要

同じTypeScriptでも**実行環境が違う**ため、設定を分けています。

---

#### 📄 `vite.config.ts`
**役割**: **フロントエンド**のビルド＆開発サーバー設定

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],           // Reactをサポート
  server: {
    port: 8080,                 // フロントエンドはポート8080
    proxy: {
      '/api': {
        target: 'http://localhost:3000',  // /apiをバックエンドに転送
        changeOrigin: true,
      }
    }
  }
})
```

**重要なポイント**:
- `port: 8080` → フロントエンドの開発サーバーのポート
- `proxy` → `/api`で始まるリクエストをバックエンド(3000番)に転送

**なぜプロキシが必要？**:
後述の「[フロントエンドとバックエンドが共存できる仕組み](#フロントエンドとバックエンドが共存できる仕組み)」で説明します。

---

#### 📄 `index.html`
**役割**: フロントエンドのHTMLテンプレート

```html
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Vite + React + Hono</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/frontend/main.tsx"></script>
  </body>
</html>
```

**重要なポイント**:
- `<div id="root"></div>` → Reactがここにコンポーネントを描画
- `<script src="/src/frontend/main.tsx">` → Reactアプリのエントリーポイント

**バックエンドは使わない？**:
はい。このHTMLファイルは**フロントエンド専用**です。バックエンドは関係ありません。

---

#### 📄 `.gitignore`
**役割**: Gitで追跡しないファイルを指定

```
node_modules/   # 依存ライブラリ（容量大）
dist/           # ビルド結果
*.log           # ログファイル
.env            # 環境変数（秘密情報）
```

---

### `src/backend/` - バックエンドディレクトリ

#### 📄 `src/backend/index.ts`
**役割**: HonoによるAPIサーバー

```typescript
import { Hono } from 'hono'
import { cors } from 'hono/cors'

const app = new Hono()

// CORS設定（フロントエンドからのアクセスを許可）
app.use('/*', cors())

// APIエンドポイント
app.get('/api', (c) => {
  return c.json({ message: 'Hello from Hono API!' })
})

// サーバー起動（ポート3000）
export default {
  port: 3000,
  fetch: app.fetch,
}
```

**重要なポイント**:
- `port: 3000` → バックエンドはポート3000で動く
- `cors()` → 別ポート(8080)のフロントエンドからアクセスを許可
- `/api` で始まるエンドポイント

---

### `src/frontend/` - フロントエンドディレクトリ

#### 📄 `src/frontend/main.tsx`
**役割**: Reactアプリのエントリーポイント

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)
```

**やっていること**:
1. `index.html`の`<div id="root">`を取得
2. そこにReactの`<App>`コンポーネントを描画

---

#### 📄 `src/frontend/App.tsx`
**役割**: Reactのメインコンポーネント

```typescript
import { useState } from 'react'

function App() {
  const [message, setMessage] = useState('')

  // バックエンドAPIを呼び出す
  const fetchMessage = async () => {
    const response = await fetch('/api')  // ← Viteがプロキシで3000番に転送
    const data = await response.json()
    setMessage(data.message)
  }

  return (
    <div>
      <button onClick={fetchMessage}>APIからメッセージを取得</button>
      {message && <div>{message}</div>}
    </div>
  )
}
```

**重要なポイント**:
- `fetch('/api')` → Viteのプロキシで`http://localhost:3000/api`に転送される

---

## フロントエンドとバックエンドが共存できる仕組み

### 基本原理: **別々のポートで動く**

```
┌─────────────────────────────────────────────────────────┐
│  開発環境                                                │
│                                                          │
│  ┌──────────────────┐        ┌──────────────────┐      │
│  │ フロントエンド    │        │ バックエンド      │      │
│  │ (Vite + React)   │        │ (Hono)           │      │
│  │ ポート: 8080     │◀──────▶│ ポート: 3000     │      │
│  └──────────────────┘ プロキシ └──────────────────┘      │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### ステップ1: 2つのサーバーが起動する

`bun run dev`を実行すると：

```bash
# 実際には以下の2つが同時実行される
bun run dev:backend  # → バックエンドがポート3000で起動
bun run dev:frontend # → フロントエンドがポート8080で起動
```

### ステップ2: それぞれが独立して動作

#### フロントエンド (ポート8080)
- Viteが開発サーバーを起動
- `index.html`を配信
- Reactアプリを実行

#### バックエンド (ポート3000)
- Bunランタイムで`src/backend/index.ts`を実行
- Honoが待機
- APIリクエストに応答

### ステップ3: Viteのプロキシで連携

ユーザーがブラウザで`http://localhost:8080`を開くと：

```
ブラウザ
  │
  ├─ http://localhost:8080/
  │    → Viteが index.html を返す
  │
  ├─ http://localhost:8080/src/frontend/main.tsx
  │    → Viteが Reactアプリ を返す
  │
  └─ http://localhost:8080/api
       → Viteがプロキシで http://localhost:3000/api に転送
       → バックエンドが応答
```

**プロキシ設定 (vite.config.ts)**:
```typescript
proxy: {
  '/api': {
    target: 'http://localhost:3000',  // 転送先
    changeOrigin: true,
  }
}
```

**何が起こる？**:
1. フロントエンドが`fetch('/api')`を実行
2. ブラウザは`http://localhost:8080/api`にリクエスト
3. Viteのプロキシが`http://localhost:3000/api`に転送
4. バックエンドが応答
5. Viteがブラウザに結果を返す

### なぜプロキシが必要？

**理由: CORSエラーを回避するため**

もしプロキシがないと：

```
ブラウザ (http://localhost:8080)
  │
  └─ fetch('http://localhost:3000/api')  ← 別ドメイン！
       → ❌ CORSエラー発生
```

**異なるポート = 異なるオリジン** なので、ブラウザがセキュリティ上ブロックします。

プロキシがあると：

```
ブラウザ (http://localhost:8080)
  │
  └─ fetch('/api')  ← 同じドメイン！
       → Viteが代理でバックエンドにリクエスト
       → ✅ OK
```

ブラウザからは「同じドメイン」に見えるため、CORSエラーが発生しません。

---

## 実行時の動作フロー

### 開発サーバー起動時

```bash
$ bun run dev
```

**内部で起こること**:

```
1. package.json の "dev" スクリプトが実行される
   ↓
2. "bun run dev:backend & bun run dev:frontend" が実行される
   ↓
3-A. バックエンド起動
   - bun が src/backend/index.ts を実行
   - Hono がポート3000で待機
   - tsconfig.backend.json の設定を使用

3-B. フロントエンド起動（同時進行）
   - vite コマンドが実行される
   - vite.config.ts の設定を読み込む
   - ポート8080で開発サーバーが起動
   - tsconfig.json の設定を使用
```

### ブラウザでアクセス時

```
ユーザー: http://localhost:8080 にアクセス
   ↓
1. Vite が index.html を返す
   ↓
2. ブラウザが index.html を読み込む
   ↓
3. <script src="/src/frontend/main.tsx"> を発見
   ↓
4. Vite が main.tsx をトランスパイル & 返す
   ↓
5. React が起動、App.tsx をレンダリング
   ↓
6. ユーザーが「APIからメッセージを取得」ボタンをクリック
   ↓
7. fetch('/api') が実行される
   ↓
8. Viteのプロキシが http://localhost:3000/api に転送
   ↓
9. バックエンド(Hono)が処理して JSON を返す
   ↓
10. Reactが受け取った JSON を画面に表示
```

---

## TypeScriptのコンパイルタイミング

### 重要な前提: tscは実際のコンパイルを担当していない

このプロジェクトでは、以下の役割分担になっています：

```
┌─────────────────────────────────────────────────┐
│  TypeScript プロジェクトでの役割分担             │
├─────────────────────────────────────────────────┤
│                                                  │
│  【実際の変換・実行】                             │
│  ├─ Vite (フロントエンド)                        │
│  │   → 開発中に自動でTS→JSに変換                │
│  │   → ブラウザで実行                            │
│  │                                               │
│  └─ Bun (バックエンド)                           │
│      → TSファイルを直接実行                       │
│      → 内部で自動変換                             │
│                                                  │
│  【型チェック専用】                               │
│  └─ tsc                                          │
│      → 自分でコマンドを打って実行                 │
│      → エラーがないか確認                         │
│      → JavaScriptファイルは作らない (--noEmit)   │
│                                                  │
└─────────────────────────────────────────────────┘
```

### Vite（フロントエンド）のコンパイルタイミング

#### 開発中（`bun run dev`）

**オンデマンド変換 = リクエストがあった時に変換**

```
1. ブラウザで http://localhost:8080 にアクセス
   ↓
2. index.html を配信
   ↓
3. ブラウザが <script src="/src/frontend/main.tsx"> を発見
   ↓
4. ブラウザが /src/frontend/main.tsx をリクエスト ← ここ！
   ↓
5. Vite が main.tsx を受け取る
   ↓
6. 【コンパイル実行】TypeScript → JavaScript に変換
   ↓
7. 変換後のJavaScriptをブラウザに返す
   ↓
8. ブラウザがJavaScriptを実行
   ↓
9. React がレンダリング
```

**重要なポイント**:
- コンパイルは**レンダリングの前**に起こる
- ブラウザが「ファイルちょうだい」と言った時に、その場で変換
- 変換結果はキャッシュされる（2回目以降は速い）

#### 開発サーバー起動時の動作

```bash
bun run dev
```

**このタイミングでは**:
```
Vite サーバーが起動
  → まだコンパイルはしない
  → リクエストを待機している状態
```

**ブラウザでアクセスした時**:
```
ブラウザ: /src/frontend/main.tsx をください
  ↓
Vite: 今から変換しますね...
  ↓
【コンパイル】main.tsx → JavaScript
  ↓
Vite: はい、どうぞ（変換後のJSを返す）
  ↓
ブラウザ: 実行します
  ↓
React: レンダリング！
```

#### ファイルを編集した時（ホットリロード）

```
1. App.tsx を編集して保存
   ↓
2. Vite がファイル変更を検知
   ↓
3. 【再コンパイル】App.tsx → JavaScript
   ↓
4. ブラウザに「更新あるよ」と通知（HMR）
   ↓
5. ブラウザが新しいファイルをリクエスト
   ↓
6. 変換済みのJavaScriptを返す
   ↓
7. React が再レンダリング
```

#### 本番ビルド（`bun run build`）

**事前に全部コンパイル = ビルド時に一括変換**

```bash
bun run build
```

**このタイミングで**:
```
1. 全ての .tsx/.ts ファイルを発見
   ↓
2. 【一括コンパイル】全ファイルを JavaScript に変換
   ↓
3. 最適化（minify、tree-shaking等）
   ↓
4. dist/ フォルダに出力

結果:
dist/
├── index.html
├── assets/
│   ├── main-abc123.js  ← 変換済み！
│   └── main-abc123.css
```

**本番環境では**:
```
ブラウザ: /assets/main-abc123.js をください
  ↓
サーバー: はい、どうぞ（既に変換済み）
  ↓
ブラウザ: 実行
  ↓
React: レンダリング
```

変換は既に終わっているので、**リクエスト時にコンパイルは不要**。

### Bun（バックエンド）のコンパイルタイミング

#### サーバー起動時（`bun run dev:backend`）

```bash
bun run dev:backend
# = bun run --hot src/backend/index.ts
```

**このタイミングで**:
```
1. Bun が src/backend/index.ts を読み込む
   ↓
2. 【コンパイル】TypeScript → 内部的にJavaScriptに変換
   ↓
3. 変換後のコードをメモリ上で実行
   ↓
4. サーバーがポート3000で起動
```

#### ファイルを編集した時（ホットリロード）

```
1. src/backend/index.ts を編集して保存
   ↓
2. Bun が変更を検知（--hot オプション）
   ↓
3. 【再コンパイル】変更されたファイルだけ変換
   ↓
4. サーバーを再起動
   ↓
5. 新しいコードで動作開始
```

#### APIリクエスト時

```
クライアント: /api にリクエスト
  ↓
Bun: 既に起動済みのコードで処理
  ↓
レスポンスを返す
```

**重要**: リクエストのたびにコンパイルは**しない**。
サーバー起動時に既に変換済みなので、そのコードで処理する。

### tsc（TypeScriptコンパイラ）の使い方

このプロジェクトでは、`tsc`は**型チェック専用**として使えます。

#### 型チェックの実行

```bash
# フロントエンドの型チェック
bun run type-check

# バックエンドの型チェック
bun run type-check:backend
```

**何が起こる**:
```
tsc が全ファイルをチェック
  → 型エラーがあれば教えてくれる
  → JavaScriptファイルは作らない (--noEmit)
  → あくまで「確認」のため

例:
src/frontend/App.tsx:10:5 - error TS2345
  Argument of type 'string' is not assignable to parameter of type 'number'.
```

### コンパイルタイミング比較表

| ツール | コンパイルタイミング | 頻度 | 用途 |
|--------|---------------------|------|------|
| **Vite（開発）** | ブラウザがファイルをリクエストした時 | ファイルごと、初回のみ（キャッシュ） | オンデマンド変換 |
| **Vite（本番）** | `bun run build` を実行した時 | 1回だけ（デプロイ前） | 事前ビルド |
| **Bun（起動）** | `bun run dev:backend` を実行した時 | サーバー起動時 | 起動時変換 |
| **Bun（編集時）** | ファイルを保存した時 | 変更のたびに再コンパイル | ホットリロード |
| **tsc** | `bun run type-check` を実行した時 | 手動実行のみ | 型チェック |

### レンダリングとの関係

#### フロントエンド（React）

```
【順序】
コンパイル → JavaScript実行 → Reactレンダリング → 画面表示
   ↑                                    ↑
  Viteがやる                          Reactがやる
```

**レンダリング時には既にコンパイルは終わっている**。

#### バックエンド（Hono）

バックエンドには「レンダリング」という概念はありません（サーバーサイドで画面を描画しないため）。

```
【順序】
コンパイル → サーバー起動 → リクエスト処理 → レスポンス返却
   ↑
  Bunがやる
```

### まとめ: コンパイルタイミング

#### Vite（フロントエンド）
- **開発時**: ブラウザがファイルをリクエストした時（レンダリングの**前**）
- **本番**: ビルド時（`bun run build`）

#### Bun（バックエンド）
- **起動時**: サーバー起動時
- **編集時**: ファイル保存時（ホットリロード）
- **リクエスト時**: コンパイルしない（既に実行中）

#### tsc（TypeScriptコンパイラ）
- **手動実行**: `bun run type-check` で型チェックのみ
- **CI/CD**: GitHub Actions等で自動実行
- **エディタ**: VSCode等が裏で使用（自動）

---

## まとめ

### フロントエンドとバックエンドが共存できる理由

1. **別々のポートで動く**
   - フロントエンド: 8080
   - バックエンド: 3000

2. **別々のエントリーポイント**
   - フロントエンド: `src/frontend/main.tsx`
   - バックエンド: `src/backend/index.ts`

3. **別々のTypeScript設定**
   - フロントエンド: `tsconfig.json`
   - バックエンド: `tsconfig.backend.json`

4. **Viteのプロキシで連携**
   - `/api`リクエストを自動転送
   - CORSエラーを回避

5. **単一のpackage.jsonで管理**
   - 両方の依存関係をまとめて管理
   - 開発コマンドで両方を同時起動

---

## よくある質問

### Q1: なぜViteはフロントエンドだけ？

**A**: Viteは**ブラウザ用のビルドツール**です。バックエンドはブラウザで動かないので、Viteは不要です。

### Q2: バックエンドもビルドが必要では？

**A**: Bunは**TypeScriptをそのまま実行できる**ので、ビルド不要です。

```bash
# ビルド不要でそのまま実行できる
bun run src/backend/index.ts
```

### Q3: 本番環境ではどうする？

**A**: フロントエンドだけビルドします：

```bash
bun run build  # Viteがフロントエンドをビルド → dist/
```

バックエンドはそのままデプロイします。

### Q4: package.jsonを分けないデメリットは？

**A**:
- 依存関係が混在する
- デプロイ時に不要なパッケージも含まれる

大規模プロジェクトでは**モノレポ化**を検討してください。

### Q5: tscはいつ使われるのか？

**A**: このプロジェクトでは、`tsc`は**型チェック専用**として使われます。

**使われる場面**:

| 場面 | 用途 | 実行方法 |
|------|------|---------|
| **開発中** | エディタの型チェック | 自動（VSCode等） |
| **手動チェック** | 型エラーの確認 | `bun run type-check` |
| **CI/CD** | コミット前の自動チェック | GitHub Actions等 |

**重要なポイント**:
- 実際のコンパイル（TS→JS変換）は**Vite/Bunが行う**
- `tsc`は**型チェックのみ**を担当（`--noEmit`オプション）
- `tsconfig.json`はVite/Bun/tscの**全てが参照する**設定ファイル

**従来のNode.jsプロジェクトとの違い**:

```bash
# 従来のやり方（tscでコンパイル）
tsc                        # TS → JS に変換
node dist/index.js         # 変換後のJSを実行

# このプロジェクト（Vite/Bunが直接実行）
bun run dev                # Vite/Bunが自動変換＆実行
bun run type-check         # 必要に応じて型チェック（任意）
```

### Q6: コンパイルはレンダリング時に行われるのか？

**A**: いいえ。コンパイルは**レンダリングの前**に完了しています。

#### フロントエンド（Vite + React）

```
【正しい順序】
1. ブラウザがファイルをリクエスト
   ↓
2. Vite がコンパイル（TS → JS）
   ↓
3. ブラウザが変換後のJSを受け取る
   ↓
4. JavaScriptを実行
   ↓
5. React がレンダリング ← ここ！
```

**重要**: レンダリングが始まる時には、既にJavaScriptに変換済みです。

#### バックエンド（Bun + Hono）

バックエンドにはレンダリングという概念がありません。

```
【順序】
1. サーバー起動時にコンパイル（TS → JS）
   ↓
2. メモリ上でJSコードが動作
   ↓
3. APIリクエストを処理
```

#### 本番環境

本番環境では、事前にビルド（コンパイル）済みです：

```bash
# ビルド時（デプロイ前）
bun run build
  → すべてのTypeScriptをJavaScriptに変換
  → dist/ フォルダに出力

# 本番環境（デプロイ後）
  → 既に変換済みのJSファイルを配信
  → コンパイルは不要
```

詳細は「[TypeScriptのコンパイルタイミング](#typescriptのコンパイルタイミング)」セクションを参照してください。